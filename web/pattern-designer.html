<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>LED Pattern Designer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background: #1a1a1a;
      color: #fff;
      padding: 10px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 24px;
      color: #00ffff;
    }

    .info {
      text-align: center;
      margin-bottom: 10px;
      font-size: 14px;
      color: #888;
    }

    .version {
      color: #0f0;
      font-size: 12px;
    }

    .canvas-container {
      background: #000;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      /* Center the square grid */
      overflow-x: auto;
    }

    #canvas {
      display: block;
      height: auto;
      image-rendering: pixelated;
      cursor: crosshair;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }

    button {
      padding: 12px;
      font-size: 16px;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 600;
      background: #2a2a2a;
      color: #fff;
    }

    button:active {
      transform: scale(0.95);
    }

    button.active {
      border-color: #00ffff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .draw-btn {
      background: #4CAF50;
    }

    .erase-btn {
      background: #f44336;
    }

    .fill-btn {
      background: #2196F3;
    }

    .clear-btn {
      background: #FF9800;
    }

    .upload-btn {
      background: #9C27B0;
      font-size: 18px;
      grid-column: 1 / -1;
    }

    .color-picker {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 8px;
      position: relative;
    }

    #colorPicker {
      width: 100%;
      height: 50px;
      border: 2px solid #fff;
      border-radius: 4px;
      cursor: pointer;
    }

    .settings {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .setting-row:last-child {
      margin-bottom: 0;
    }

    label {
      font-weight: 600;
    }

    input[type="text"],
    input[type="number"] {
      padding: 8px;
      font-size: 14px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a1a;
      color: #fff;
      width: 200px;
    }

    .status {
      text-align: center;
      padding: 10px;
      border-radius: 8px;
      margin-top: 15px;
      font-weight: 600;
      display: none;
    }

    .status.success {
      background: #4CAF50;
    }

    .status.error {
      background: #f44336;
    }

    .status.info {
      background: #2196F3;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 20px;
      }

      .controls {
        grid-template-columns: repeat(2, 1fr);
      }

      input[type="text"],
      input[type="number"] {
        width: 150px;
      }
    }

    .tabs {
      display: flex;
      margin-bottom: 15px;
      border-bottom: 2px solid #444;
    }

    .tab-btn {
      flex: 1;
      padding: 10px;
      background: #2a2a2a;
      border: none;
      border-bottom: 3px solid transparent;
      color: #888;
      cursor: pointer;
      font-size: 16px;
      border-radius: 8px 8px 0 0;
      margin-right: 5px;
    }

    .tab-btn.active {
      background: #333;
      color: #fff;
      border-bottom-color: #00ffff;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üé® LED Pattern Designer</h1>
    <div class="info">32 √ó 32 Grid | 4 Vertical Panels | Column Zigzag</div>
    <div class="version">v3.2 - 32x32 Matrix</div>

    <div class="tabs">
      <button class="tab-btn active" onclick="openTab('tab-draw')">‚úèÔ∏è Draw Pattern</button>
      <button class="tab-btn" onclick="openTab('tab-text')">üìù Scrolling Text</button>
    </div>

    <div id="tab-draw" class="tab-content active">
      <div class="canvas-container">
        <canvas id="canvas"></canvas>
      </div>

      <div class="controls">
        <button class="draw-btn active" onclick="setTool('draw')">‚úèÔ∏è Draw</button>
        <button class="erase-btn" onclick="setTool('erase')">üßπ Erase</button>
        <button class="fill-btn" onclick="fillAll()">üé® Fill</button>
        <button class="clear-btn" onclick="clearCanvas()">üóëÔ∏è Clear</button>
        <div class="color-picker">
          <input type="color" id="colorPicker" value="#ff0000">
        </div>
      </div>

      <div class="settings">
        <div class="setting-row">
          <label>Layout:</label>
          <select id="layoutSelect" onchange="changeLayout()">
            <option value="32x32">32 x 32 (4 Panels Vertical)</option>
            <option value="128x8">128 x 8 (4 Panels Horizontal)</option>
          </select>
        </div>
        <div class="setting-row">
          <label>Scroll Speed (0=Static):</label>
          <input type="number" id="scrollSpeed" value="0" min="0" max="200">
        </div>
      </div>

      <button class="upload-btn" onclick="uploadToESP()">üöÄ Upload to ESP8266</button>
      <div id="status" class="status"></div>
    </div>

    <div id="tab-text" class="tab-content">
      <div class="settings">
        <div class="setting-row">
          <label>Text to Scroll:</label>
          <input type="text" id="scrollText" value="HELLO WORLD" placeholder="Enter text..." style="width: 200px;">
        </div>
        <div style="margin-top: 10px; text-align: center;">
          <button class="upload-btn" onclick="sendText()">üì® Send Text</button>
        </div>
      </div>
    </div>

    <script>
      let GRID_WIDTH = 32;
      let GRID_HEIGHT = 32;
      const CELL_WIDTH = 20;
      const CELL_HEIGHT = 20;

      // Removed global canvas/ctx to avoid stale references

      let currentTool = 'draw';
      let currentColor = '#ff0000';
      let isDrawing = false;
      let pattern = [];

      // Initialize
      function init() {
        const canvas = document.getElementById('canvas');
        // Update canvas size
        canvas.width = GRID_WIDTH * CELL_WIDTH;
        canvas.height = GRID_HEIGHT * CELL_HEIGHT;

        // Reset pattern if dimensions changed or first run
        if (pattern.length !== GRID_HEIGHT || pattern[0].length !== GRID_WIDTH) {
          pattern = Array(GRID_HEIGHT).fill(null).map(() =>
            Array(GRID_WIDTH).fill(null).map(() => [0, 0, 0])
          );
        }

        setupEvents();
        redrawCanvas();
      }

      async function changeLayout() {
        const layout = document.getElementById('layoutSelect').value;
        let rows, cols;

        if (layout === '128x8') {
          GRID_WIDTH = 128;
          GRID_HEIGHT = 8;
          document.querySelector('.info').textContent = "128 √ó 8 Grid | 4 Horizontal Panels";
          rows = 1;
          cols = 4;
        } else {
          GRID_WIDTH = 32;
          GRID_HEIGHT = 32;
          document.querySelector('.info').textContent = "32 √ó 32 Grid | 4 Vertical Panels";
          rows = 4;
          cols = 1;
        }

        // Reset pattern for new layout
        pattern = Array(GRID_HEIGHT).fill(null).map(() =>
          Array(GRID_WIDTH).fill(null).map(() => [0, 0, 0])
        );

        init();

        // Sync with ESP8266
        try {
          await fetch(`/api/setPanels?rows=${rows}&cols=${cols}`);
          showStatus(`Layout changed to ${layout}`, 'success');
        } catch (e) {
          console.error("Failed to sync layout", e);
        }
      }

      function getGridCoordinates(clientX, clientY) {
        const canvas = document.getElementById('canvas');
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const canvasX = (clientX - rect.left) * scaleX;
        const canvasY = (clientY - rect.top) * scaleY;
        const x = Math.floor(canvasX / CELL_WIDTH);
        const y = Math.floor(canvasY / CELL_HEIGHT);
        return { x, y };
      }

      function handlePointerDown(clientX, clientY) {
        isDrawing = true;
        drawPixel(clientX, clientY);
      }

      function handlePointerMove(clientX, clientY) {
        if (!isDrawing) return;
        drawPixel(clientX, clientY);
      }

      function handlePointerUp() {
        isDrawing = false;
      }

      function drawPixel(clientX, clientY) {
        const { x, y } = getGridCoordinates(clientX, clientY);
        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
          if (currentTool === 'draw') {
            pattern[y][x] = hexToRgb(currentColor);
          } else if (currentTool === 'erase') {
            pattern[y][x] = [0, 0, 0];
          }
          redrawCanvas();
        }
      }

      function setupEvents() {
        const canvas = document.getElementById('canvas');
        // Remove old listeners to avoid duplicates (cloning canvas)
        const newCanvas = canvas.cloneNode(true);
        canvas.parentNode.replaceChild(newCanvas, canvas);
        // We need to re-get the element and context after replacement
        const freshCanvas = document.getElementById('canvas');

        freshCanvas.addEventListener('mousedown', (e) => {
          e.preventDefault();
          handlePointerDown(e.clientX, e.clientY);
        });
        freshCanvas.addEventListener('mousemove', (e) => {
          handlePointerMove(e.clientX, e.clientY);
        });
        freshCanvas.addEventListener('mouseup', () => handlePointerUp());
        freshCanvas.addEventListener('mouseleave', () => handlePointerUp());

        freshCanvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          handlePointerDown(e.touches[0].clientX, e.touches[0].clientY);
        });
        freshCanvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
        });
        freshCanvas.addEventListener('touchend', () => handlePointerUp());

        // Color picker
        const cp = document.getElementById('colorPicker');
        const newCp = cp.cloneNode(true);
        cp.parentNode.replaceChild(newCp, cp);
        document.getElementById('colorPicker').addEventListener('change', (e) => {
          currentColor = e.target.value;
        });
      }

      function setTool(tool) {
        currentTool = tool;
        document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
        if (tool === 'draw') document.querySelector('.draw-btn').classList.add('active');
        if (tool === 'erase') document.querySelector('.erase-btn').classList.add('active');
      }

      function clearCanvas() {
        pattern = Array(GRID_HEIGHT).fill(null).map(() =>
          Array(GRID_WIDTH).fill(null).map(() => [0, 0, 0])
        );
        redrawCanvas();
      }

      function fillAll() {
        const rgb = hexToRgb(currentColor);
        pattern = Array(GRID_HEIGHT).fill(null).map(() =>
          Array(GRID_WIDTH).fill(null).map(() => [...rgb])
        );
        redrawCanvas();
      }

      function redrawCanvas() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);

        const ledSize = CELL_WIDTH - 2;

        for (let y = 0; y < GRID_HEIGHT; y++) {
          for (let x = 0; x < GRID_WIDTH; x++) {
            const [r, g, b] = pattern[y][x];
            const centerX = x * CELL_WIDTH + CELL_WIDTH / 2;
            const centerY = y * CELL_HEIGHT + CELL_HEIGHT / 2;
            const radius = ledSize / 2;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#222';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            if (r > 0 || g > 0 || b > 0) {
              ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
              ctx.fill();
              ctx.shadowBlur = 5;
              ctx.shadowColor = `rgb(${r}, ${g}, ${b})`;
              ctx.fill();
              ctx.shadowBlur = 0;
            }
          }
        }

        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;

        for (let x = 0; x <= GRID_WIDTH; x++) {
          ctx.beginPath();
          ctx.moveTo(x * CELL_WIDTH, 0);
          ctx.lineTo(x * CELL_WIDTH, height);
          if (GRID_WIDTH === 128 && x % 32 === 0 && x > 0 && x < 128) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#555';
          } else {
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#222';
          }
          ctx.stroke();
        }

        for (let y = 0; y <= GRID_HEIGHT; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * CELL_HEIGHT);
          ctx.lineTo(width, y * CELL_HEIGHT);
          if (GRID_HEIGHT === 32 && y % 8 === 0 && y > 0 && y < 32) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#555';
          } else {
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#222';
          }
          ctx.stroke();
        }
      }

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        ] : [255, 0, 0];
      }

      function openTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        document.getElementById(tabName).classList.add('active');
      }

      // Tab click handlers
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', function () {
          // Already handled by onclick in HTML calling openTab? 
          // But we need to update active class on buttons too.
          document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
        });
      });

      function showStatus(message, type = 'info') {
        const statusDiv = document.getElementById('status');
        statusDiv.textContent = message;
        statusDiv.className = 'status ' + type;
        statusDiv.style.display = 'block';
        setTimeout(() => statusDiv.style.display = 'none', 5000);
      }

      async function setPattern(mode) {
        showStatus(`Setting pattern ${mode}...`, 'info');
        try {
          const response = await fetch(`/api/set?m=${mode}`);
          if (response.ok) {
            showStatus(`‚úÖ Pattern ${mode} set!`, 'success');
          } else {
            showStatus('‚ùå Failed to set pattern', 'error');
          }
        } catch (error) {
          showStatus('‚ùå Error: ' + error.message, 'error');
        }
      }

      async function uploadToESP() {
        const scrollSpeed = parseInt(document.getElementById('scrollSpeed').value);
        showStatus('Uploading...', 'info');

        try {
          const numLeds = GRID_WIDTH * GRID_HEIGHT;
          const sparseData = [];

          for (let x = 0; x < GRID_WIDTH; x++) {
            for (let y = 0; y < GRID_HEIGHT; y++) {
              const [r, g, b] = pattern[y][x];
              if (r === 0 && g === 0 && b === 0) continue;

              let stripIndex;

              if (GRID_WIDTH === 32 && GRID_HEIGHT === 32) {
                // 32x32: 4 Panels Vertical Stack (Serpentine)
                const panelRow = Math.floor(y / 8);
                const localX = x;
                const localY = y % 8;
                const panelIndex = panelRow;
                const panelOffset = panelIndex * 256;

                let finalLocalX = localX;
                let finalLocalY = localY;

                if (panelRow % 2 === 1) {
                  finalLocalX = 31 - localX;
                  finalLocalY = 7 - localY;
                }

                let localIndex;
                if (finalLocalX % 2 === 0) {
                  localIndex = finalLocalX * 8 + finalLocalY;
                } else {
                  localIndex = finalLocalX * 8 + (7 - finalLocalY);
                }
                stripIndex = panelOffset + localIndex;

              } else {
                // 128x8: 4 Panels Horizontal (Linear)
                const panelCol = Math.floor(x / 32);
                const localX = x % 32;
                const localY = y;
                const panelIndex = panelCol;
                const panelOffset = panelIndex * 256;

                let localIndex;
                if (localX % 2 === 0) {
                  localIndex = localX * 8 + localY;
                } else {
                  localIndex = localX * 8 + (7 - localY);
                }
                stripIndex = panelOffset + localIndex;
              }

              if (stripIndex < numLeds) {
                sparseData.push([stripIndex, r, g, b]);
              }
            }
          }

          const estimatedRawSize = numLeds * 3;
          const estimatedSparseSize = sparseData.length * 18;

          if (estimatedSparseSize < estimatedRawSize) {
            console.log(`Using Sparse format (${estimatedSparseSize} bytes vs ${estimatedRawSize} bytes)`);
            const payload = JSON.stringify({
              sparse: sparseData,
              scrollSpeed: scrollSpeed
            });

            const response = await fetch(`/api/uploadPattern`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: payload
            });

            if (response.ok) {
              showStatus(`‚úÖ Uploaded!`, 'success');
            } else {
              showStatus('‚ùå Upload failed: ' + response.statusText, 'error');
            }

          } else {
            console.log(`Using Raw format (${estimatedRawSize} bytes vs ${estimatedSparseSize} bytes)`);

            const rawData = new Uint8Array(numLeds * 3);

            for (let x = 0; x < GRID_WIDTH; x++) {
              for (let y = 0; y < GRID_HEIGHT; y++) {
                const [r, g, b] = pattern[y][x];

                let stripIndex;
                if (GRID_WIDTH === 32 && GRID_HEIGHT === 32) {
                  const panelRow = Math.floor(y / 8);
                  const localX = x;
                  const localY = y % 8;
                  const panelIndex = panelRow;
                  const panelOffset = panelIndex * 256;
                  let finalLocalX = localX;
                  let finalLocalY = localY;
                  if (panelRow % 2 === 1) {
                    finalLocalX = 31 - localX;
                    finalLocalY = 7 - localY;
                  }
                  let localIndex;
                  if (finalLocalX % 2 === 0) {
                    localIndex = finalLocalX * 8 + finalLocalY;
                  } else {
                    localIndex = finalLocalX * 8 + (7 - finalLocalY);
                  }
                  stripIndex = panelOffset + localIndex;
                } else {
                  const panelCol = Math.floor(x / 32);
                  const localX = x % 32;
                  const localY = y;
                  const panelIndex = panelCol;
                  const panelOffset = panelIndex * 256;
                  let localIndex;
                  if (localX % 2 === 0) {
                    localIndex = localX * 8 + localY;
                  } else {
                    localIndex = localX * 8 + (7 - localY);
                  }
                  stripIndex = panelOffset + localIndex;
                }

                if (stripIndex < numLeds) {
                  rawData[stripIndex * 3] = r;
                  rawData[stripIndex * 3 + 1] = g;
                  rawData[stripIndex * 3 + 2] = b;
                }
              }
            }

            const response = await fetch(`/api/uploadRaw?speed=${scrollSpeed}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/octet-stream' },
              body: rawData
            });

            if (response.ok) {
              showStatus(`‚úÖ Uploaded!`, 'success');
            } else {
              showStatus('‚ùå Upload failed: ' + response.statusText, 'error');
            }
          }
        } catch (error) {
          showStatus('‚ùå Error: ' + error.message, 'error');
        }
      }

      async function sendText() {
        const text = document.getElementById('scrollText').value;
        const speed = document.getElementById('scrollSpeed').value;

        showStatus(`Sending text: ${text}...`, 'info');
        try {
          const response = await fetch(`/api/setText?text=${encodeURIComponent(text)}&speed=${speed}`);
          if (response.ok) {
            showStatus('‚úÖ Text sent!', 'success');
          } else {
            showStatus('‚ùå Failed to send text', 'error');
          }
        } catch (error) {
          showStatus('‚ùå Error: ' + error.message, 'error');
        }
      }

      // Start
      init();
    </script>
</body>

</html>