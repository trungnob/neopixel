<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>C++ Pattern Simulator - Using main.cpp</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: #1a1a1a;
      color: #fff;
      margin: 0;
      padding: 10px;
      display: flex;
      height: 100vh;
    }

    .left-panel {
      width: 30%;
      padding: 10px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .right-panel {
      width: 70%;
      padding: 10px;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 20px;
      color: #00ffff;
    }

    .info {
      background: #2a2a2a;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .controls {
      background: #2a2a2a;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
    }

    .controls button {
      padding: 8px 16px;
      margin: 5px 5px 5px 0;
      background: #00ffff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      font-size: 12px;
    }

    .controls button:hover { background: #00cccc; }
    .controls button.active {
      background: #ff00ff;
    }

    .pattern-list {
      background: #2a2a2a;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
      max-height: 500px;
      overflow-y: auto;
    }

    .pattern-item {
      padding: 5px;
      margin: 2px 0;
      background: #1a1a1a;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }

    .pattern-item:hover {
      background: #333;
    }

    .pattern-item.active {
      background: #00ffff;
      color: #000;
      font-weight: bold;
    }

    canvas {
      border: 2px solid #333;
      background: #2b2318;
      display: block;
      margin: 0 auto;
      image-rendering: pixelated;
    }

    .stats {
      color: #888;
      font-size: 12px;
      margin-top: 10px;
      text-align: center;
    }

    .loading {
      color: #00ffff;
      text-align: center;
      padding: 20px;
    }

    label {
      display: block;
      margin: 5px 0;
      font-size: 12px;
    }

    input[type="range"] {
      width: 100%;
    }
  </style>
</head>
<body>
  <div class="left-panel">
    <h1>üé® C++ Simulator</h1>

    <div class="info">
      <strong>Source:</strong> main.cpp (live)<br>
      <strong>Grid:</strong> 144√ó9 LEDs<br>
      <strong>Wiring:</strong> Zigzag
    </div>

    <div class="controls">
      <button onclick="toggleAnimation()">‚ñ∂ Play / ‚è∏ Pause</button>
      <button onclick="stepFrame()">‚è≠ Step</button>
      <button onclick="resetPattern()">üîÑ Reset</button>

      <label>
        FPS: <span id="fpsValue">30</span>
        <input type="range" id="fpsSlider" min="1" max="60" value="30"
               oninput="updateFPS(this.value)">
      </label>

      <label>
        Brightness: <span id="brightnessValue">255</span>
        <input type="range" id="brightnessSlider" min="10" max="255" value="255"
               oninput="updateBrightness(this.value)">
      </label>
    </div>

    <div class="pattern-list" id="patternList">
      <div class="loading">Loading patterns from main.cpp...</div>
    </div>
  </div>

  <div class="right-panel">
    <canvas id="ledCanvas"></canvas>
    <div class="stats" id="stats">Initializing...</div>
  </div>

  <script>
    // ===== Configuration =====
    const GRID_WIDTH = 144;
    const GRID_HEIGHT = 9;
    const STRIP_LENGTH_MM = 1000;
    const STRIP_SPACING_MM = 50;
    const LED_SPACING_H_MM = 1000 / 144;
    const LED_SIZE_MM = 5;
    const SCALE = 0.8;
    const MARGIN_X = 40;
    const MARGIN_Y = 40;

    const canvas = document.getElementById('ledCanvas');
    const ctx = canvas.getContext('2d');

    const ledGridWidth = STRIP_LENGTH_MM * SCALE;
    const ledGridHeight = (GRID_HEIGHT - 1) * STRIP_SPACING_MM * SCALE;
    canvas.width = ledGridWidth + (MARGIN_X * 2);
    canvas.height = ledGridHeight + (MARGIN_Y * 2);

    const LED_DISPLAY_SIZE = LED_SIZE_MM * SCALE;

    // ===== LED State =====
    let leds = new Array(GRID_WIDTH * GRID_HEIGHT);
    for(let i = 0; i < leds.length; i++) {
      leds[i] = {r: 0, g: 0, b: 0};
    }

    let hue = 0;
    let animationId = null;
    let currentPattern = 100;
    let frameCount = 0;
    let startTime = Date.now();
    let fps = 30;
    let brightness = 255;
    let activeLeds = GRID_WIDTH * GRID_HEIGHT;

    // Pattern-specific variables
    let scrollOffset = 0;
    let scrollSpeed = 80;
    let gameOfLifeGrid = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
    let heat = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);

    // ===== FastLED Emulation =====

    function XY(x, y) {
      if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return -1;
      if (y % 2 === 0) {
        return y * GRID_WIDTH + x;
      } else {
        return y * GRID_WIDTH + (GRID_WIDTH - 1 - x);
      }
    }

    function CHSV(h, s, v) {
      return HSVtoRGB(h, s, v);
    }

    function CRGB(r, g, b) {
      if (typeof r === 'object') return r;
      return {r: r || 0, g: g || 0, b: b || 0};
    }

    const CRGBColors = {
      Black: {r: 0, g: 0, b: 0},
      Red: {r: 255, g: 0, b: 0},
      Green: {r: 0, g: 255, b: 0},
      Blue: {r: 0, g: 0, b: 255},
      Yellow: {r: 255, g: 255, b: 0},
      Orange: {r: 255, g: 165, b: 0},
      Purple: {r: 128, g: 0, b: 128},
      Cyan: {r: 0, g: 255, b: 255},
      Magenta: {r: 255, g: 0, b: 255},
      White: {r: 255, g: 255, b: 255}
    };

    function HSVtoRGB(h, s, v) {
      h = h / 255.0;
      s = s / 255.0;
      v = v / 255.0;

      let r, g, b;
      let i = Math.floor(h * 6);
      let f = h * 6 - i;
      let p = v * (1 - s);
      let q = v * (1 - f * s);
      let t = v * (1 - (1 - f) * s);

      switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
      }

      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
      };
    }

    function HeatColor(temp) {
      let t192 = Math.round((temp / 255.0) * 191);
      let heatramp = t192 & 0x3F;
      heatramp <<= 2;

      if (t192 & 0x80) {
        return {r: 255, g: 255, b: heatramp};
      } else if (t192 & 0x40) {
        return {r: 255, g: heatramp, b: 0};
      } else {
        return {r: heatramp, g: 0, b: 0};
      }
    }

    function sin8(x) {
      return Math.round((Math.sin(x * Math.PI / 128) + 1) * 127.5);
    }

    function cos8(x) {
      return Math.round((Math.cos(x * Math.PI / 128) + 1) * 127.5);
    }

    function beatsin8(bpm, min_val, max_val, offset, phase) {
      min_val = min_val || 0;
      max_val = max_val || 255;
      offset = offset || 0;
      phase = phase || 0;

      let beat = (Date.now() * bpm / 60000.0) + phase / 255.0;
      let val = (Math.sin(beat * 2 * Math.PI) + 1) * 0.5;
      return Math.round(min_val + val * (max_val - min_val));
    }

    function beatsin16(bpm, min_val, max_val, offset, phase) {
      return beatsin8(bpm, min_val, max_val, offset, phase);
    }

    function random8(min, max) {
      if (max === undefined) {
        max = min || 255;
        min = 0;
      }
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function random16(max) {
      max = max || 65535;
      return Math.floor(Math.random() * (max + 1));
    }

    function inoise8(x, y, z) {
      const p = Math.sin(x * 0.01) * Math.cos(y * 0.01) * Math.sin((z || 0) * 0.01);
      return Math.round(((p + 1) * 0.5) * 255);
    }

    function fill_solid(arr, count, color) {
      if (typeof count === 'object') {
        color = count;
        count = arr.length;
      }
      for(let i = 0; i < count; i++) {
        arr[i] = {...color};
      }
    }

    function fadeToBlackBy(arr, count, amount) {
      for(let i = 0; i < count; i++) {
        arr[i].r = Math.max(0, arr[i].r - amount);
        arr[i].g = Math.max(0, arr[i].g - amount);
        arr[i].b = Math.max(0, arr[i].b - amount);
      }
    }

    function qsub8(a, b) {
      return Math.max(0, a - b);
    }

    function qadd8(a, b) {
      return Math.min(255, a + b);
    }

    function blur1d(arr, count, amount) {
      // Simple blur - not perfect but close enough
      for(let i = 1; i < count - 1; i++) {
        arr[i].r = (arr[i-1].r + arr[i].r + arr[i+1].r) / 3;
        arr[i].g = (arr[i-1].g + arr[i].g + arr[i+1].g) / 3;
        arr[i].b = (arr[i-1].b + arr[i].b + arr[i+1].b) / 3;
      }
    }

    let millis = () => Date.now();

    // ===== Render Function =====

    function render() {
      // Cardboard background
      ctx.fillStyle = '#2b2318';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // LED grid background
      ctx.fillStyle = '#000';
      ctx.fillRect(MARGIN_X - 5, MARGIN_Y - 5, ledGridWidth + 10, ledGridHeight + 10);

      // Strip backgrounds
      ctx.fillStyle = '#1a1a1a';
      for(let y = 0; y < GRID_HEIGHT; y++) {
        const stripY = MARGIN_Y + (y * STRIP_SPACING_MM * SCALE);
        ctx.fillRect(MARGIN_X - 5, stripY - 2, ledGridWidth + 10, LED_SIZE_MM * SCALE + 4);
      }

      // Draw LEDs
      for(let y = 0; y < GRID_HEIGHT; y++) {
        for(let x = 0; x < GRID_WIDTH; x++) {
          const led = XY(x, y);
          if (led >= 0 && led < leds.length) {
            let color = leds[led];

            // Apply brightness
            color = {
              r: Math.round(color.r * brightness / 255),
              g: Math.round(color.g * brightness / 255),
              b: Math.round(color.b * brightness / 255)
            };

            const ledX = MARGIN_X + (x * LED_SPACING_H_MM) * SCALE;
            const ledY = MARGIN_Y + (y * STRIP_SPACING_MM) * SCALE;

            const bright = (color.r + color.g + color.b) / 3;

            if (bright > 10) {
              // Glow effect
              const gradient = ctx.createRadialGradient(
                ledX, ledY, 0,
                ledX, ledY, LED_DISPLAY_SIZE * 2
              );
              gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`);
              gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`);
              gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);

              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(ledX, ledY, LED_DISPLAY_SIZE * 2, 0, Math.PI * 2);
              ctx.fill();
            }

            // LED core
            ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            ctx.beginPath();
            ctx.arc(ledX, ledY, LED_DISPLAY_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();

            if (bright < 10) {
              ctx.strokeStyle = '#333';
              ctx.lineWidth = 0.5;
              ctx.stroke();
            }
          }
        }
      }

      // Measurement guides
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);

      for(let x = 0; x <= STRIP_LENGTH_MM; x += 100) {
        const px = MARGIN_X + (x * SCALE);
        ctx.beginPath();
        ctx.moveTo(px, MARGIN_Y);
        ctx.lineTo(px, MARGIN_Y + ledGridHeight);
        ctx.stroke();
      }

      for(let y = 0; y < GRID_HEIGHT; y++) {
        const py = MARGIN_Y + (y * STRIP_SPACING_MM * SCALE);
        ctx.beginPath();
        ctx.moveTo(MARGIN_X, py);
        ctx.lineTo(MARGIN_X + ledGridWidth, py);
        ctx.stroke();
      }

      ctx.setLineDash([]);
    }

    // ===== Load and Parse main.cpp =====

    let patterns = {};

    async function loadMainCpp() {
      try {
        const response = await fetch('src/main.cpp');
        const code = await response.text();

        // Parse 2D patterns (100-120)
        const caseRegex = /case\s+(\d+):\s*\/\/\s*(.+?)[\r\n]/g;
        let match;

        while ((match = caseRegex.exec(code)) !== null) {
          const caseNum = parseInt(match[1]);
          const description = match[2].trim();

          if (caseNum >= 100) {
            patterns[caseNum] = {
              number: caseNum,
              name: description,
              code: null
            };
          }
        }

        displayPatternList();
        document.getElementById('stats').textContent = `Loaded ${Object.keys(patterns).length} patterns from main.cpp`;

        return true;
      } catch (error) {
        console.error('Failed to load main.cpp:', error);
        document.getElementById('patternList').innerHTML =
          '<div style="color: #ff0000;">Failed to load main.cpp. Make sure the file is accessible.</div>';
        return false;
      }
    }

    function displayPatternList() {
      const list = document.getElementById('patternList');
      list.innerHTML = '';

      const sortedPatterns = Object.values(patterns).sort((a, b) => a.number - b.number);

      sortedPatterns.forEach(pattern => {
        const div = document.createElement('div');
        div.className = 'pattern-item';
        if (pattern.number === currentPattern) div.classList.add('active');
        div.textContent = `${pattern.number}: ${pattern.name}`;
        div.onclick = () => selectPattern(pattern.number);
        list.appendChild(div);
      });
    }

    function selectPattern(num) {
      currentPattern = num;
      resetPattern();
      displayPatternList();
    }

    function resetPattern() {
      hue = 0;
      scrollOffset = 0;
      frameCount = 0;
      startTime = Date.now();
      for(let i = 0; i < leds.length; i++) {
        leds[i] = {r: 0, g: 0, b: 0};
      }
      gameOfLifeGrid.fill(Math.random() > 0.7 ? 1 : 0);
      heat.fill(0);
    }

    // ===== Animation Control =====

    function toggleAnimation() {
      if (animationId) {
        clearInterval(animationId);
        animationId = null;
      } else {
        const interval = 1000 / fps;
        animationId = setInterval(animate, interval);
      }
    }

    function stepFrame() {
      animate();
    }

    function updateFPS(value) {
      fps = parseInt(value);
      document.getElementById('fpsValue').textContent = fps;

      if (animationId) {
        clearInterval(animationId);
        const interval = 1000 / fps;
        animationId = setInterval(animate, interval);
      }
    }

    function updateBrightness(value) {
      brightness = parseInt(value);
      document.getElementById('brightnessValue').textContent = brightness;
      render();
    }

    function animate() {
      // Run the actual pattern code from main.cpp
      runPattern(currentPattern);
      render();

      frameCount++;
      const elapsed = (Date.now() - startTime) / 1000;
      const actualFPS = frameCount / elapsed;
      document.getElementById('stats').textContent =
        `Pattern ${currentPattern} | Frame: ${frameCount} | FPS: ${actualFPS.toFixed(1)} | Hue: ${hue}`;
    }

    // ===== Pattern Execution (Copied from main.cpp) =====
    // This will be filled with actual pattern code

    function runPattern(patternNum) {
      // Include actual pattern implementations from main.cpp
      // For now, including the key 2D patterns manually

      switch(patternNum) {
        
        case 100: // Horizontal Bars - Each strip a different cycling color
          for(let y=0; y<GRID_HEIGHT; y++) {
          let stripHue = (hue + y * 28) % 256;
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) leds[led] = CHSV(stripHue, 255, 255);
          }
        }
        hue++;
          break;


        case 101: // Vertical Ripple - Waves moving vertically
          for(let y=0; y<GRID_HEIGHT; y++) {
          let brightness = beatsin8(20, 0, 255, 0, y*32);
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) leds[led] = CHSV(hue, 255, brightness);
          }
        }
        hue++;
          break;


        case 102: // 2D Fire Rising - Fire effect rising from bottom
          if (typeof heat2d_p102 === 'undefined') {
            heat2d_p102 = [];
            for(let i = 0; i < GRID_HEIGHT; i++) {
              heat2d_p102[i] = new Array(GRID_WIDTH).fill(0);
            }
          }
          
          // Cool down every cell
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              heat2d_p102[y][x] = qsub8(heat2d_p102[y][x], random8(0, 20));
            }
          }
          // Heat rises
          for(let y=GRID_HEIGHT-1; y>0; y--) {
            for(let x=0; x<GRID_WIDTH; x++) {
              heat2d_p102[y][x] = (heat2d_p102[y-1][x] + heat2d_p102[y][x]) / 2;
            }
          }
          // Add new fire at bottom
          for(let x=0; x<GRID_WIDTH; x++) {
            if(random8() < 120) {
              heat2d_p102[0][x] = qadd8(heat2d_p102[0][x], random8(160, 255));
            }
          }
          // Convert to LED colors
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              let led = XY(x, y);
              if (led >= 0) leds[led] = HeatColor(heat2d_p102[y][x]);
            }
          }
        }
          break;


        case 103: // Rain Drops - Droplets falling down
          // Shift everything down
          for(let y=0; y<GRID_HEIGHT-1; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              let led = XY(x, y);
              let ledAbove = XY(x, y+1);
              if (led >= 0 && ledAbove >= 0) {
                leds[led] = leds[ledAbove];
                leds[led].fadeToBlackBy(10);
              }
            }
          }
          // Add new drops at top
          for(let x=0; x<GRID_WIDTH; x++) {
            if (random8() < 30) {
              let led = XY(x, GRID_HEIGHT-1);
              if (led >= 0) leds[led] = CHSV(160, 255, 255);
            }
          }
        }
          break;


        case 104: // Vertical Equalizer - Each strip is a bar
          for(let y=0; y<GRID_HEIGHT; y++) {
          let barHeight = beatsin8(40 + y*5, 0, GRID_WIDTH);
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              if (x < barHeight) {
                let barHue = (y * 255) / GRID_HEIGHT;
                leds[led] = CHSV(barHue, 255, 255);
              } else {
                leds[led] = CRGBColors.Black;
              }
            }
          }
        }
          break;


        case 105: // Scanning Lines - Horizontal lines moving up/down
          if (typeof scanLine_p105 === 'undefined') scanLine_p105 = 0;
          
          fill_solid(leds, activeLeds, CRGBColors.Black);
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, scanLine_p105);
            if (led >= 0) leds[led] = CHSV(hue, 255, 255);
            // Add trail
            let led2 = XY(x, (scanLine_p105 + 1) % GRID_HEIGHT);
            if (led2 >= 0) leds[led2] = CHSV(hue, 255, 128);
          }
          EVERY_N_MILLISECONDS(100) {
            scanLine_p105 = (scanLine_p105 + 1) % GRID_HEIGHT;
            hue += 5;
          }
        }
          break;


        case 106: // Checkerboard - Classic 2D pattern
          let cellSize = 8;
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              let led = XY(x, y);
              if (led >= 0) {
                let isWhite = ((x/cellSize) + (y)) % 2 == (hue/50) % 2;
                if (isWhite) {
                  leds[led] = CHSV(hue, 255, 255);
                } else {
                  leds[led] = CRGBColors.Black;
                }
              }
            }
          }
          hue++;
        }
          break;


        case 107: // Diagonal Sweep - Diagonal lines moving
          for(let y=0; y<GRID_HEIGHT; y++) {
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              let dist = (x + y*10 + hue*2) % 256;
              leds[led] = CHSV(dist, 255, sin8(dist));
            }
          }
        }
        hue++;
          break;


        case 108: // Vertical Wave - Sine wave across strips
          for(let y=0; y<GRID_HEIGHT; y++) {
          let yPos = beatsin8(15, 0, GRID_WIDTH-1, 0, y*20);
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              let dist = abs(x - yPos);
              let brightness = dist < 5 ? 255 - (dist*50) : 0;
              leds[led] = CHSV(hue + y*28, 255, brightness);
            }
          }
        }
        hue++;
          break;


        case 109: // Plasma 2D - Full 2D plasma effect
          for(let y=0; y<GRID_HEIGHT; y++) {
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              let wave1 = sin8((x * 8) + (hue));
              let wave2 = sin8((y * 16) + (hue * 2));
              let wave3 = sin8(((x + y) * 6) + (hue * 3));
              let combined = (wave1 + wave2 + wave3) / 3;
              leds[led] = CHSV(combined, 255, 255);
            }
          }
        }
        hue++;
          break;


        case 110: // Matrix Rain 2D - Proper Matrix effect with columns
          if (typeof drops_p110 === 'undefined') drops_p110 = new Array(GRID_WIDTH).fill(0);
          if (typeof initialized110_p110 === 'undefined') initialized110_p110 = false;
          
          

          if (!initialized110_p110) {
            for(let x=0; x<GRID_WIDTH; x++) {
              drops_p110[x] = random8(GRID_HEIGHT);
            }
            initialized110_p110 = true;
          }

          fadeToBlackBy(leds, activeLeds, 40);

          for(let x=0; x<GRID_WIDTH; x++) {
            // Draw the head (bright green)
            let led = XY(x, drops_p110[x]);
            if (led >= 0) leds[led] = CRGBColors.Green;

            // Move drop down
            if (random8() < 100) {
              drops_p110[x] = (drops_p110[x] - 1 + GRID_HEIGHT) % GRID_HEIGHT;
            }
          }
        }
          break;


        case 111: // Game of Life - Conway's cellular automaton
          if (typeof grid_p111 === 'undefined') {
            grid_p111 = [];
            for(let i = 0; i < GRID_HEIGHT; i++) {
              grid_p111[i] = new Array(GRID_WIDTH).fill(0);
            }
          }
          if (typeof nextGrid_p111 === 'undefined') {
            nextGrid_p111 = [];
            for(let i = 0; i < GRID_HEIGHT; i++) {
              nextGrid_p111[i] = new Array(GRID_WIDTH).fill(0);
            }
          }
          if (typeof lastUpdate_p111 === 'undefined') lastUpdate_p111 = 0;
          if (typeof initialized111_p111 === 'undefined') initialized111_p111 = false;
          
          
          
          

          if (!initialized111_p111) {
            // Random initial state
            for(let y=0; y<GRID_HEIGHT; y++) {
              for(let x=0; x<GRID_WIDTH; x++) {
                grid_p111[y][x] = random8(100) < 30 ? 1 : 0;
              }
            }
            initialized111_p111 = true;
          }

          if (Date.now() - lastUpdate_p111 > 200) {
            // Apply Game of Life rules
            for(let y=0; y<GRID_HEIGHT; y++) {
              for(let x=0; x<GRID_WIDTH; x++) {
                // Count neighbors
                let neighbors = 0;
                for(let dy=-1; dy<=1; dy++) {
                  for(let dx=-1; dx<=1; dx++) {
                    if (dx==0 && dy==0) continue;
                    let ny = (y + dy + GRID_HEIGHT) % GRID_HEIGHT;
                    let nx = (x + dx + GRID_WIDTH) % GRID_WIDTH;
                    neighbors += grid_p111[ny][nx];
                  }
                }
                // Conway's rules
                if (grid_p111[y][x] == 1) {
                  nextGrid_p111[y][x] = (neighbors == 2 || neighbors == 3) ? 1 : 0;
                } else {
                  nextGrid_p111[y][x] = (neighbors == 3) ? 1 : 0;
                }
              }
            }
            // Copy next to current
            memcpy(grid_p111, nextGrid_p111, sizeof(grid_p111));
            lastUpdate_p111 = Date.now();
          }

          // Draw to LEDs
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              let led = XY(x, y);
              if (led >= 0) {
                if (grid_p111[y][x]) {
                  leds[led] = CHSV(hue, 255, 255);
                } else {
                  leds[led] = CRGBColors.Black;
                }
              }
            }
          }
          hue++;
        }
          break;


        case 112: // Wave Pool - Horizontal waves perfect for 1m strips
          for(let y=0; y<GRID_HEIGHT; y++) {
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              let wave1 = sin8((x * 3) + (hue * 2));
              let wave2 = sin8((x * 2) - (hue * 3) + (y * 20));
              let brightness = (wave1 + wave2) / 2;
              leds[led] = CHSV(160, 255, brightness);
            }
          }
        }
        hue++;
          break;


        case 113: // Aurora 2D - Optimized for horizontal strips
          for(let y=0; y<GRID_HEIGHT; y++) {
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              // Horizontal waves with vertical variation
              let wave1 = sin8((x * 2) + (hue * 3));
              let wave2 = sin8((x * 3) - (hue * 2) + (y * 30));
              let colorVal = 80 + ((wave1 + wave2) / 8);
              let brightness = (wave1 + wave2) / 2;
              leds[led] = CHSV(colorVal, 200, brightness);
            }
          }
        }
        hue++;
          break;


        case 114: // Lava Lamp 2D - Aspect-ratio corrected blobs
          for(let y=0; y<GRID_HEIGHT; y++) {
          for(let x=0; x<GRID_WIDTH; x++) {
            let led = XY(x, y);
            if (led >= 0) {
              // Correct for aspect ratio in noise calculation
              let blob1 = inoise8(x * 10, y * 70, hue * 2);
              let blob2 = inoise8(x * 15, y * 100, hue * 3 + 10000);
              let combined = (blob1 + blob2) / 2;
              leds[led] = HeatColor(combined);
            }
          }
        }
        hue++;
          break;


        case 115: // 2D Ripple - Aspect-ratio corrected circles
          if (typeof centerX_p115 === 'undefined') centerX_p115 = GRID_WIDTH / 2;
          if (typeof centerY_p115 === 'undefined') centerY_p115 = GRID_HEIGHT / 2;
          
          

          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              let led = XY(x, y);
              if (led >= 0) {
                // Calculate distance with aspect ratio correction
                let dx = (x - centerX_p115);
                let dy = (y - centerY_p115) * ASPECT_RATIO;
                let dist = sqrt(dx*dx + dy*dy);
                let brightness = sin8((dist * 10) - (hue * 3));
                leds[led] = CHSV(hue + (dist * 2), 255, brightness);
              }
            }
          }
          hue += 2;

          EVERY_N_SECONDS(5) {
            centerX_p115 = random16(GRID_WIDTH);
            centerY_p115 = random16(GRID_HEIGHT);
          }
        }
          break;


        case 116: // Starfield Parallax - Stars moving at different speeds
          if (typeof stars_p116 === 'undefined') {
            stars_p116 = [];
            for(let i = 0; i < 20; i++) {
              stars_p116[i] = new Array(3).fill(0);
            }
          }
          if (typeof initialized116_p116 === 'undefined') initialized116_p116 = false;
           // x, y, speed
          

          if (!initialized116_p116) {
            for(let i=0; i<20; i++) {
              stars_p116[i][0] = random16(GRID_WIDTH);
              stars_p116[i][1] = random16(GRID_HEIGHT);
              stars_p116[i][2] = random8(1, 5) / 10.0;
            }
            initialized116_p116 = true;
          }

          fadeToBlackBy(leds, activeLeds, 30);

          for(let i=0; i<20; i++) {
            let led = XY(stars_p116[i][0], stars_p116[i][1]);
            if (led >= 0) {
              let brightness = 100 + (stars_p116[i][2] * 300);
              leds[led] = CRGB(brightness, brightness, brightness);
            }

            // Move star
            stars_p116[i][0] -= stars_p116[i][2];
            if (stars_p116[i][0] < 0) {
              stars_p116[i][0] = GRID_WIDTH - 1;
              stars_p116[i][1] = random16(GRID_HEIGHT);
            }
          }
        }
          break;


        case 117: // Side Fire - Fire from left and right edges
          if (typeof heatLeft_p117 === 'undefined') {
            heatLeft_p117 = [];
            for(let i = 0; i < GRID_HEIGHT; i++) {
              heatLeft_p117[i] = new Array(GRID_WIDTH/2).fill(0);
            }
          }
          if (typeof heatRight_p117 === 'undefined') {
            heatRight_p117 = [];
            for(let i = 0; i < GRID_HEIGHT; i++) {
              heatRight_p117[i] = new Array(GRID_WIDTH/2).fill(0);
            }
          }
          
          

          // Cool down
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH/2; x++) {
              heatLeft_p117[y][x] = qsub8(heatLeft_p117[y][x], random8(0, 15));
              heatRight_p117[y][x] = qsub8(heatRight_p117[y][x], random8(0, 15));
            }
          }

          // Heat spreads inward
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=GRID_WIDTH/2-1; x>0; x--) {
              heatLeft_p117[y][x] = (heatLeft_p117[y][x-1] + heatLeft_p117[y][x]) / 2;
              heatRight_p117[y][x] = (heatRight_p117[y][x-1] + heatRight_p117[y][x]) / 2;
            }
          }

          // Add new fire at edges
          for(let y=0; y<GRID_HEIGHT; y++) {
            if(random8() < 120) {
              heatLeft_p117[y][0] = qadd8(heatLeft_p117[y][0], random8(160, 255));
              heatRight_p117[y][0] = qadd8(heatRight_p117[y][0], random8(160, 255));
            }
          }

          // Draw to LEDs
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH/2; x++) {
              let ledLeft = XY(x, y);
              let ledRight = XY(GRID_WIDTH - 1 - x, y);
              if (ledLeft >= 0) leds[ledLeft] = HeatColor(heatLeft_p117[y][x]);
              if (ledRight >= 0) leds[ledRight] = HeatColor(heatRight_p117[y][x]);
            }
          }
        }
          break;


        case 118: // Scrolling Rainbow - Smooth horizontal scroll
          if (typeof scrollPos_p118 === 'undefined') scrollPos_p118 = 0;
          
          for(let y=0; y<GRID_HEIGHT; y++) {
            for(let x=0; x<GRID_WIDTH; x++) {
              let led = XY(x, y);
              if (led >= 0) {
                let colorIndex = ((x + scrollPos_p118) * 256 / GRID_WIDTH) + (y * 20);
                leds[led] = CHSV(colorIndex, 255, 255);
              }
            }
          }
          EVERY_N_MILLISECONDS(50) {
            scrollPos_p118 = (scrollPos_p118 + 1) % GRID_WIDTH;
          }
        }
          break;


        case 119: // Particle Fountain - Particles shoot up from bottom
          const NUM_PARTICLES = 30;
          if (typeof particles_p119 === 'undefined') {
            particles_p119 = [];
            for(let i = 0; i < NUM_PARTICLES; i++) {
              particles_p119[i] = new Array(4).fill(0);
            }
          }
          if (typeof initialized119_p119 === 'undefined') initialized119_p119 = false;
                     // x, y, vx, vy
          

          if (!initialized119_p119) {
            for(let i=0; i<NUM_PARTICLES; i++) {
              particles_p119[i][0] = GRID_WIDTH / 2;
              particles_p119[i][1] = 0;
              particles_p119[i][2] = (random8(200) - 100) / 10.0;
              particles_p119[i][3] = random8(10, 30) / 10.0;
            }
            initialized119_p119 = true;
          }

          fadeToBlackBy(leds, activeLeds, 40);

          for(let i=0; i<NUM_PARTICLES; i++) {
            // Draw particle
            let led = XY(particles_p119[i][0], particles_p119[i][1]);
            if (led >= 0) {
              leds[led] = CHSV(hue + i*8, 255, 255);
            }

            // Update physics (corrected for aspect ratio)
            particles_p119[i][2] *= 0.99; // Air resistance
            particles_p119[i][3] -= 0.15; // Gravity (adjusted for vertical spacing)
            particles_p119[i][0] += particles_p119[i][2];
            particles_p119[i][1] += particles_p119[i][3] / ASPECT_RATIO;

            // Reset if out of bounds
            if (particles_p119[i][1] < 0 || particles_p119[i][0] < 0 || particles_p119[i][0] >= GRID_WIDTH) {
              particles_p119[i][0] = GRID_WIDTH / 2 + random8(40) - 20;
              particles_p119[i][1] = 0;
              particles_p119[i][2] = (random8(200) - 100) / 10.0;
              particles_p119[i][3] = random8(10, 30) / 10.0;
            }
          }
          hue++;
        }
          break;


        case 120: // Scrolling Text - Aspect-ratio corrected for 7.2:1 physical spacing
          if (typeof lastScrollTime_p120 === 'undefined') lastScrollTime_p120 = 0;
          fill_solid(leds, activeLeds, CRGBColors.Black);

          // Aspect ratio compensation: vertical is 7.2x taller than horizontal
          // To make letters look square, make them ~7x wider in LED count
          const let scaleX = 7;  // Horizontal scale (to compensate for tight spacing)
          const let scaleY = 1;  // Vertical scale (keep it 1:1 since spacing is already wide)
          const let charSpacing = 5;  // Gap between characters

          // Calculate scaled dimensions
          let scaledFontWidth = FONT_WIDTH * scaleX;
          let scaledFontHeight = FONT_HEIGHT * scaleY;
          let charWidth = scaledFontWidth + charSpacing;

          // Calculate total text width
          let textWidth = scrollText.length() * charWidth;

          // Draw each character
          for(let charIdx = 0; charIdx < scrollText.length(); charIdx++) {
            char c = scrollText[charIdx];
            let fontIdx = getFontIndex(c);

            // Starting X position for this character
            let charX = GRID_WIDTH + charIdx * charWidth - scrollOffset;

            // Only draw if character is visible on screen
            if (charX < GRID_WIDTH && charX + scaledFontWidth > 0) {
              // Draw each column of the character
              for(let col = 0; col < FONT_WIDTH; col++) {
                let columnData = pgm_read_byte(&font5x7[fontIdx][col]);

                // Draw each row of the column
                for(let row = 0; row < FONT_HEIGHT; row++) {
                  if (columnData & (1 << row)) {
                    // Scale pixels with aspect ratio compensation
                    for(let dy = 0; dy < scaleY; dy++) {
                      for(let dx = 0; dx < scaleX; dx++) {
                        // Calculate position on grid (use all 9 rows, no centering)
                        let y = row * scaleY + dy + 1;  // Start at row 1
                        let x = charX + col * scaleX + dx;

                        // Only draw if within grid bounds
                        if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
                          let led = XY(x, y);
                          if (led >= 0) {
                            leds[led] = CHSV(hue, 255, 255);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          // Scroll the text using configurable speed
          
          if (Date.now() - lastScrollTime_p120 > scrollSpeed) {
            scrollOffset++;
            // Reset when text has fully scrolled off screen
            if (scrollOffset > GRID_WIDTH + textWidth) {
              scrollOffset = 0;
            }
            lastScrollTime_p120 = Date.now();
          }

          hue++;
        }
          break;

      }
    }

    // ===== Initialize =====

    async function init() {
      await loadMainCpp();
      render();

      // Auto-start animation
      toggleAnimation();
    }

    init();
  </script>
</body>
</html>
